<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perspective Projection</title>
</head>
<body>


    <canvas id="canvas" width="800" height="600"></canvas>
    
    <script>

        const vector3d = (x, y, z) => { return {x, y, z} }; 
        const triangle = (a, b, c) => { return {points:[a, b, c]} };
        const mesh = () => {return {triangles:[]}};

        const meshCube = mesh();

        meshCube.triangles = [

            //back
            triangle(vector3d(-.5, -.5, -2), vector3d(.5, -.5, -2), vector3d(.5, .5, -2)),
            triangle(vector3d(.5, .5, -2), vector3d(-.5, .5, -2), vector3d(-.5, -.5, -2)),            
            //front
            triangle(vector3d(.5, -.5, -1), vector3d(-.5, -.5, -1), vector3d(-.5, .5, -1)),
            triangle(vector3d(-.5, .5, -1), vector3d(.5, .5, -1), vector3d(.5, -.5, -1)),
          
            //top
            triangle(vector3d(-.5, .5, -1), vector3d(-.5, .5, -2), vector3d(.5, .5, -2)),
            triangle(vector3d(.5, .5, -2), vector3d(.5, .5, -1), vector3d(-.5, .5, -1)),
            //bottom
            triangle(vector3d(-.5, -.5, -2), vector3d(-.5, -.5, -1), vector3d(.5, -.5, -1)),
            triangle(vector3d(.5, -.5, -1), vector3d(.5, -.5, -2), vector3d(-.5, -.5, -2)),
            //left
            triangle(vector3d(-.5, -.5, -1), vector3d(-.5, .5, -1), vector3d(-.5, .5, -2)),
            triangle(vector3d(-.5, .5, -2), vector3d(-.5, -.5, -2), vector3d(-.5, -.5, -1)),
            //right
            triangle(vector3d(.5, -.5, -2), vector3d(.5, -.5, -1), vector3d(.5, .5, -1)),
            triangle(vector3d(.5, .5, -1), vector3d(.5, .5, -2), vector3d(.5, -.5, -2))

        ];

        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');

        //console.log(meshCube)

        //context.rotate(Math.PI / 2);
        context.strokeStyle = 'white';


        const matrixUniformScaling = (scale) => [

            [scale, 0, 0, 0],
            [0, scale, 0, 0],
            [0, 0, scale, 0],
            [0, 0, 0, 1]

        ];



        const matrixRotationX = (angle) => [

            [1, 0, 0, 0],
            [0, Math.cos(angle), -Math.sin(angle), 0],
            [0, Math.sin(angle), Math.cos(angle), 0],    
            [0, 0, 0, 1]

        ];

        const matrixRotationY = (angle) => [

            [Math.cos(angle), 0, Math.sin(angle), 0],
            [0, 1, 0, 0],
            [-Math.sin(angle), 0, Math.cos(angle), 0],    
            [0, 0, 0, 1]

        ];

        const matrixRotationZ = (angle) => [

            [Math.cos(angle), -Math.sin(angle), 0, 0],
            [Math.sin(angle), Math.cos(angle), 0, 0],
            [0, 0, 1, 0],
            [0, 0, 0, 1]

        ];

        const f = 100;
        const n = .1;
        const fov = 90;
        const s = (fov) => 1 / Math.tan(fov * .5 * Math.PI / 180);

        const matrixPerspective = (fov, f, n) => [

            [s(fov), 0, 0, 0],
            [0, s(fov), 0, 0],
            [0, 0, -f / (f -n), -1],
            [0, 0, -f * n / (f -n), 0]

        ];


        const crossProduct = (vectorA, vectorB) => {

            return {

                x: vectorA.y * vectorB.z - vectorA.z * vectorB.y,
                y: vectorA.z * vectorB.x - vectorA.x * vectorB.z,
                z: vectorA.x * vectorB.y - vectorA.y * vectorB.x

            }
        }

        const multiplyMatrix = (vector, matrix) => {
            
            const result = {
                x: vector.x * matrix[0][0] + vector.y * matrix[1][0] + vector.z * matrix[2][0] + matrix[3][0],
                y: vector.x * matrix[0][1] + vector.y * matrix[1][1] + vector.z * matrix[2][1] + matrix[3][1],
                z: vector.x * matrix[0][2] + vector.y * matrix[1][2] + vector.z * matrix[2][2] + matrix[3][2],        
                w: vector.x * matrix[0][3] + vector.y * matrix[1][3] + vector.z * matrix[2][3] + matrix[3][3]         
            }

            if(result.w != 1){

                result.x /= 3 - result.w
                result.y /= 3 - result.w
                result.z /= result.w 
                result.w /= result.w

            }           
            
            return result;
        }


        //meshCube.triangles = meshCube.triangles.filter((f, index, o) => {
        //    return index == 0 
        //});
        let angle = 0;

        const TWO_PI =  Math.PI * 2;
        function loop(){

            context.save();
            context.fillRect(0, 0, 800, 600);
            context.translate(400, 300);           
          
        //console.log(meshCube.triangles);
            meshCube.triangles.forEach((triangle, index) => {

                const current = 0
                
            //  context.strokeStyle = index == current || index == current + 1 ? "red" : "white"  
    //            context.lineWidth = index == current || index == current + 1 ? 5 : 1

                const points = triangle.points.map(point => {

                
                // const pointRotatedX =  multiplyMatrix(point, matrixRotationX(Math.PI / 4));
                //  const pointRotatedY =  multiplyMatrix(point, matrixRotationY(Math.PI / 4));
                // const pointRotatedZ =  multiplyMatrix(pointRotatedY, matrixRotationZ(Math.PI / 2));
                
                
                const pointRotatedY =  multiplyMatrix(point, matrixRotationY(angle));
                const pointPerspective = multiplyMatrix(pointRotatedY, matrixPerspective(fov, f, n));  

                const pointScaled = multiplyMatrix(pointPerspective, matrixUniformScaling(200)); 
                     
                    
                    //const pointScaled = multiplyMatrix(pointPerspective, matrixUniformScaling(10));
                    const transformedPoint = pointScaled;

                    
                //  console.table(pointScaled)
                    return transformedPoint;
                })
                
                
               // console.table(points) 
                context.beginPath();            
                context.moveTo(points[0].x, points[0].y);   
                context.lineTo(points[1].x, points[1].y);    
                context.lineTo(points[2].x, points[2].y);  
                context.lineTo(points[0].x, points[0].y);                 
                context.closePath();
                context.fillStyle = "blue";
                context.stroke();
                context.fill();

            

            });

        context.restore();

        angle += 0.01;
        //console.log(angle)
        if(angle == 3.14) {

              console.log(angle)
             angle = 0
        }
        requestAnimationFrame(loop)
    }
       
        loop()
    </script>
        
</body>
</html>
