<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perspective Projection</title>
</head>
<body>

    <canvas id="canvas" width="800" height="600"></canvas>
    
    <script>

        const vector3d = (x, y, z) => { return {x, y, z} }; 
        const triangle = (a, b, c) => { return {points:[a, b, c]} };
        const mesh = () => {return {triangles:[]}};

        const meshCube = mesh();

        meshCube.triangles = [
            //front
            triangle(vector3d(1, 0, 0), vector3d(0, 0, 0), vector3d(0, 1, 0)),
            triangle(vector3d(0, 1, 0), vector3d(1, 1, 0), vector3d(1, 0, 0)),
            //back
            triangle(vector3d(0, 0, -1), vector3d(1, 0, -1), vector3d(1, 1, -1)),
            triangle(vector3d(1, 1, -1), vector3d(0, 1, -1), vector3d(0, 0, -1)),
            //top
            triangle(vector3d(0, 1, 0), vector3d(0, 1, -1), vector3d(1, 1, -1)),
            triangle(vector3d(1, 1, -1), vector3d(1, 1, 0), vector3d(0, 1, 0)),
            //bottom
            triangle(vector3d(0, 0, -1), vector3d(0, 0, 0), vector3d(1, 0, 0)),
            triangle(vector3d(1, 0, 0), vector3d(1, 0, -1), vector3d(0, 0, -1)),
            //left
            triangle(vector3d(0, 0, 0), vector3d(0, 1, 0), vector3d(0, 1, -1)),
            triangle(vector3d(0, 1, -1), vector3d(0, 0, -1), vector3d(0, 0, 0)),
            //right
            triangle(vector3d(1, 0, -1), vector3d(1, 0, 0), vector3d(1, 1, 0)),
            triangle(vector3d(1, 1, 0), vector3d(1, 1, -1), vector3d(1, 0, -1))

        ];

        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');

        //console.log(meshCube)
        context.fillRect(0, 0, 800, 600);
        context.translate(400, 300);
        //context.rotate(Math.PI / 2);
        context.strokeStyle = 'white';


        const matrixUniformScaling = (scale) => [

            [scale, 0, 0, 0],
            [0, scale, 0, 0],
            [0, 0, scale, 0],
            [0, 0, 0, 1]

        ];



        const matrixRotationX = (angle) => [

            [1, 0, 0, 0],
            [0, Math.cos(angle), -Math.sin(angle), 0],
            [0, Math.sin(angle), Math.cos(angle), 0],    
            [0, 0, 0, 1]

        ];

        const matrixRotationY = (angle) => [

            [Math.cos(angle), 0, Math.sin(angle), 0],
            [0, 1, 0, 0],
            [-Math.sin(angle), 0, Math.cos(angle), 0],    
            [0, 0, 0, 1]

        ];

        const matrixRotationZ = (angle) => [

            [Math.cos(angle), -Math.sin(angle), 0, 0],
            [Math.sin(angle), Math.cos(angle), 0, 0],
            [0, 0, 1, 0],
            [0, 0, 0, 1]

        ];

        const f = 100;
        const n = .1;
        const fov = 90;
        const s = (fov) => 1 / Math.tan(fov * .5 * Math.PI / 180);

        const matrixPerspective = (fov, f, n) => [

            [s(fov), 0, 0, 0],
            [0, s(fov), 0, 0],
            [0, 0, -f / (f -n), -1],
            [0, 0, -f * n / (f -n), 0]

        ];

        const multiplyMatrix = (vector, matrix) => {
            
            const result = {
                x: vector.x * matrix[0][0] + vector.y * matrix[1][0] + vector.z * matrix[2][0] + matrix[3][0],
                y: vector.x * matrix[0][1] + vector.y * matrix[1][1] + vector.z * matrix[2][1] + matrix[3][1],
                z: vector.x * matrix[0][2] + vector.y * matrix[1][2] + vector.z * matrix[2][2] + matrix[3][2],        
                w: vector.x * matrix[0][3] + vector.y * matrix[1][3] + vector.z * matrix[2][3] + matrix[3][3],        
            }

            if(result.w == 0) return result;

            result.x /= result.w
            result.y /= result.w
            result.z /= result.w
            result.w /= result.w
            
            return result;
        }


        //meshCube.triangles = meshCube.triangles.filter((f, index, o) => {
        //    return index == 0 
        //});

        //console.log(meshCube.triangles);
        meshCube.triangles.forEach(triangle =>{

            const points = triangle.points.map(point => {

                
               // const pointRotatedX =  multiplyMatrix(point, matrixRotationX(Math.PI / 4));
               // const pointRotatedY =  multiplyMatrix(pointRotatedX, matrixRotationY(Math.PI / 4));
               // const pointRotatedZ =  multiplyMatrix(pointRotatedY, matrixRotationZ(Math.PI / 2));
                const pointScaled = multiplyMatrix(point, matrixUniformScaling(100));
                const pointPerspective = multiplyMatrix(point, matrixPerspective(fov, f, n));
                
                //const pointScaled = multiplyMatrix(pointPerspective, matrixUniformScaling(10));
                const transformedPoint = pointPerspective;

                return transformedPoint;
            })
            
        
            context.beginPath();
            
            context.moveTo(points[0].x, points[0].y);   
            context.lineTo(points[1].x, points[1].y);    
            context.lineTo(points[2].x, points[2].y);  
            context.lineTo(points[0].x, points[0].y); 
            context.closePath();
            context.stroke();

        });


    </script>
        
</body>
</html>
